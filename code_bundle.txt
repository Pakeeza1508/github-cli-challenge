=== gh-focus.cmd ===
@echo off
REM GitHub CLI extension entry point for Windows
REM This script runs the Python CLI

setlocal

REM Get the directory where the extension is installed
set "EXTENSION_DIR=%~dp0"

REM Check if Python is installed
where python >nul 2>nul
if %errorlevel% neq 0 (
    echo Error: Python is required but not found.
    echo Please install Python 3.7+ from https://www.python.org/downloads/
    exit /b 1
)

REM Check if virtual environment exists, create if not
if not exist "%EXTENSION_DIR%gh-focus\venv" (
    echo Setting up gh-focus for first time...
    python -m venv "%EXTENSION_DIR%gh-focus\venv"
    call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"
    pip install -q -r "%EXTENSION_DIR%gh-focus\requirements.txt"
    echo Setup complete!
)

REM Activate virtual environment
call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"

REM Run the actual Python script
cd /d "%EXTENSION_DIR%gh-focus"
python gh-focus %*

=== gh-focus/requirements.txt ===
feedparser>=6.0.10
questionary>=2.0.1
rich>=13.7.0
yt-dlp>=2023.0.0

=== CHALLENGE 6: Channel ID Resolution ===

def resolve_channel_id(user_input):
    # If already an ID, use it directly
    if re.match(r'^UC[a-zA-Z0-9_-]{20,}$', user_input):
        return user_input

    patterns = [
        (r'youtube\.com/@(.+?)(?:/|$)', 'handle'),
        (r'youtube\.com/c/(.+?)(?:/|$)', 'custom'),
        (r'youtube\.com/user/(.+?)(?:/|$)', 'user'),
    ]
    
    for pattern, url_type in patterns:
        match = re.search(pattern, user_input)
        if match:
            identifier = match.group(1)
            feed_url = f"https://www.youtube.com/feeds/videos.xml?user={identifier}"
            feed = feedparser.parse(feed_url)
            return extract_channel_id_from_feed(feed)
    
    try:
        info = subprocess.run(
            ['yt-dlp', '-j', '--skip-download', user_input],
            capture_output=True, text=True, timeout=10
        )
        data = json.loads(info.stdout)
        return data['channel_id']
    except:
        raise ValueError(f"Could not resolve channel: {user_input}")

=== CHALLENGE 7: RSS Feed Edge Cases ===

def load_channel_videos(channel_id, use_cache=True):
    cache_file = f'cache/{channel_id}_videos.json'
    if use_cache and os.path.exists(cache_file):
        cached = json.load(open(cache_file))
        if is_recent(cached['timestamp']):
            return cached['videos']
    
    feed = feedparser.parse(f"https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}")
    videos = parse_feed(feed)
    
    os.makedirs('cache', exist_ok=True)
    json.dump({'timestamp': time.time(), 'videos': videos}, open(cache_file, 'w'))
    
    return videos

def play_video(video_id):
    try:
        subprocess.run(['mpv', f'https://www.youtube.com/watch?v={video_id}'])
    except Exception as e:
        if '403' in str(e):
            print("‚ö†Ô∏è  This video is private or unlisted")
        elif '404' in str(e):
            print("‚ö†Ô∏è  This video was deleted by creator")
        else:
            print(f"‚ö†Ô∏è  Error: {e}")

def get_video_metadata(rss_entry):
    metadata = {
        'title': rss_entry.get('title', 'Unknown'),
        'published': rss_entry.get('published', 'Unknown'),
        'video_id': extract_video_id(rss_entry['id']),
    }
    
    if 'media_thumbnail' in rss_entry:
        metadata['thumbnail'] = rss_entry['media_thumbnail'][0]['url']
    else:
        metadata['thumbnail'] = f"https://i.ytimg.com/vi/{metadata['video_id']}/default.jpg"
    
    return metadata

=== CHALLENGE 8: Watch History & Gist Sync ===

def log_watch(video_title, channel, video_id):
    timestamp = datetime.now().isoformat()
    entry = {
        'title': video_title,
        'channel': channel,
        'video_id': video_id,
        'timestamp': timestamp,
        'synced': False
    }
    
    watch_history = load_watch_history()
    watch_history.append(entry)
    save_watch_history(watch_history)
    
    return entry

def ask_sync_to_gist(entry):
    response = questionary.select(
        f'Save "{entry["title"]}" to GitHub Gist?',
        choices=[
            'Yes - Save to public learning log',
            'No - Keep local only',
            'Don\'t ask again'
        ]
    ).ask()
    
    if response.startswith('Yes'):
        sync_to_gist(entry)
        entry['synced'] = True
        save_watch_history_entry(entry)

def sync_to_gist(entry):
    try:
        gist_id = load_gist_id()
        
        if gist_id:
            new_entry = f"\n- [{entry['title']}](https://youtube.com/watch?v={entry['video_id']}) - {entry['channel']} - {entry['timestamp']}"
            
            subprocess.run([
                'gh', 'gist', 'edit', gist_id,
                '--add', 'learning_log.md:' + new_entry
            ])
        else:
            content = f"# My Learning Log\n\nCreated {datetime.now().date()}\n\n" + \
                      f"- [{entry['title']}](https://youtube.com/watch?v={entry['video_id']}) - {entry['channel']}"
            
            result = subprocess.run([
                'gh', 'gist', 'create',
                '--public',
                '--description', 'My gh-focus Learning Log',
                '--filename', 'learning_log.md',
                '-'
            ], input=content, capture_output=True, text=True)
            
            gist_id = extract_gist_id(result.stdout)
            save_gist_id(gist_id)
            
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not sync to Gist: {e}")
        print("   Saved locally. Try again later when online.")

def is_duplicate(new_entry):
    existing = load_watch_history()
    
    for entry in existing:
        if (entry['video_id'] == new_entry['video_id'] and
            entry['timestamp'][:10] == new_entry['timestamp'][:10]):
            return True
    
    return False

=== CHALLENGE 9: Terminal UI Rendering ===

def show_main_menu():
    categories = list(config['categories'].keys())
    
    selected = questionary.select(
        "üìö YOUR LEARNING CATEGORIES",
        choices=categories + [
            Separator(),
            "üìä View Stats",
            "üì∫ View Learning Log",
            "üîé Open Channel",
            "+ Add New Channel",
            "üóëÔ∏è  Remove Channel",
            "Exit"
        ]
    ).ask()
    
    if selected in categories:
        show_videos_for_category(selected)

def show_videos_for_category(category):
    channels = config['categories'][category]
    
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = {
            executor.submit(fetch_channel_videos, ch_id): ch_name 
            for ch_name, ch_id in channels.items()
        }
        
        videos = []
        for future in as_completed(futures):
            channel_name = futures[future]
            try:
                videos.extend(future.result())
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to load {channel_name}: {e}")
    
    show_video_table(videos)

def format_video_title(title, max_width=50):
    if len(title) <= max_width:
        return title
    
    truncated = title[:max_width-3]
    last_space = truncated.rfind(' ')
    
    if last_space > max_width // 2:
        truncated = truncated[:last_space]
    
    return truncated + "..."

def get_available_colors():
    term = os.environ.get('TERM', '')
    
    if 'truecolor' in term or '256color' in term:
        return 'full'
    elif 'color' in term:
        return 'basic'
    else:
        return 'none'

=== CHALLENGE 10: GitHub CLI Extension Integration ===

# extension.yml
name: focus
description: A GitHub CLI extension for distraction-free YouTube learning
owner: Pakeeza1508
repo: github-cli-challenge
hosts:
  - github.com
  - github.enterprise.com
executables:
- name: gh-focus
  os: !include
    linux: gh-focus
    darwin: gh-focus
    windows: gh-focus.cmd

# Windows wrapper (gh-focus.cmd)
@echo off
REM Get the directory where this script is located
set SCRIPT_DIR=%~dp0

REM Find Python
where python >nul 2>nul
if %ERRORLEVEL% == 0 (
    python "%SCRIPT_DIR%gh-focus.py" %*
    goto end
)

where python3 >nul 2>nul
if %ERRORLEVEL% == 0 (
    python3 "%SCRIPT_DIR%gh-focus.py" %*
    goto end
)

echo Error: Python 3 not found
echo Please install Python from https://www.python.org
exit /b 1

:end

# Unix wrapper (gh-focus)
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if command -v python3 &> /dev/null; then
    exec python3 "$SCRIPT_DIR/gh-focus.py" "$@"
fi

if command -v python &> /dev/null; then
    exec python "$SCRIPT_DIR/gh-focus.py" "$@"
fi

echo "Error: Python 3 not found"
echo "Install Python from https://www.python.org"
exit 1

# Main script startup
if __name__ == "__main__":
    import sys
    
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

=== CHALLENGE 11: Security & Input Validation ===

def validate_youtube_url(url_or_id):
    if re.match(r'^UC[a-zA-Z0-9_-]{22}$', url_or_id):
        return 'channel_id', url_or_id
    
    if re.match(r'^[a-zA-Z0-9_-]{11}$', url_or_id):
        return 'video_id', url_or_id
    
    patterns = {
        r'(?:https?://)?(?:www\.)?youtube\.com/@([a-zA-Z0-9._-]+)/?$': 'handle',
        r'(?:https?://)?(?:www\.)?youtube\.com/c/([a-zA-Z0-9_-]+)/?$': 'custom',
        r'(?:https?://)?(?:www\.)?youtube\.com/user/([a-zA-Z0-9_-]+)/?$': 'user',
        r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]{11})': 'video_page',
    }
    
    for pattern, url_type in patterns.items():
        match = re.match(pattern, url_or_id)
        if match:
            return url_type, match.group(1)
    
    raise ValueError(f"Invalid YouTube URL or ID: {url_or_id}")

def safe_play_video(video_id):
    subprocess.run(
        ['mpv', f'https://www.youtube.com/watch?v={video_id}'],
        shell=False,
        check=False
    )

def load_config_safely():
    if not os.path.exists('config.json'):
        raise FileNotFoundError("config.json not found")
    
    if os.path.getsize('config.json') > 10 * 1024 * 1024:
        raise ValueError("config.json too large (max 10MB)")
    
    with open('config.json') as f:
        config = json.load(f)
    
    if not isinstance(config, dict):
        raise ValueError("config.json must be a JSON object")
    
    for category, channels in config.items():
        if not isinstance(category, str):
            raise ValueError(f"Category name must be string, got {type(category)}")
        
        if not isinstance(channels, dict):
            raise ValueError(f"Channels in '{category}' must be dict")
        
        for name, channel_id in channels.items():
            if not re.match(r'^UC[a-zA-Z0-9_-]{22}$', channel_id):
                raise ValueError(f"Invalid channel ID: {channel_id}")
    
    return config

=== CHALLENGE 12: Testing ===

# tests/test_channel_resolution.py
import pytest
from focus_manager import resolve_channel_id

def test_direct_channel_id():
    channel_id = "UCsBjURrPoezykLs9EqgamOA"
    result = resolve_channel_id(channel_id)
    assert result == channel_id

def test_youtube_url_parsing():
    test_cases = [
        ("https://youtube.com/@Fireship", "UCsBjURrPoezykLs9EqgamOA"),
        ("https://youtube.com/c/Fireship", "UCsBjURrPoezykLs9EqgamOA"),
        ("https://youtube.com/user/Fireship", "UCsBjURrPoezykLs9EqgamOA"),
    ]
    
    for url, expected_id in test_cases:
        result = resolve_channel_id(url)
        assert result == expected_id

def test_invalid_input():
    with pytest.raises(ValueError):
        resolve_channel_id("not_a_valid_id_or_url")

# GitHub Actions workflow (.github/workflows/test.yml)
name: Test gh-focus

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12']
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Test basic functionality
        run: python -m pytest tests/
      
      - name: Test without MPV (fallback)
        run: |
          export PATH=/nonexistent:$PATH
          python -m pytest tests/test_player_fallback.py
      
      - name: Test config loading
        run: python -m pytest tests/test_config.py

=== gh-focus/config.json.sample ===
{
    "coding": [
        {
            "name": "Fireship",
            "id": "UCsBjURrPoezykLs9EqgamOA"
        },
        {
            "name": "Traversy Media",
            "id": "UC29ju8bIPH5as8OGnQzwJyA"
        },
        {
            "name": "Web Dev Simplified",
            "id": "UCFbNIlppjreqWp0LoG4qLDg"
        },
        {
            "name": "The Net Ninja",
            "id": "UCW5YeuERMlsx2D7KtykVbVA"
        }
    ],
    "business": [
        {
            "name": "Y Combinator",
            "id": "UCcefcZRL2oaA_uBNeo5UOWg"
        },
        {
            "name": "Ali Abdaal",
            "id": "UCoOae5nYzcosPVc4DescXIQ"
        },
        {
            "name": "MeetKevin",
            "id": "UCdWjx1aWCM6iB2lt-dEKD8w"
        }
    ],
    "learning": [
        {
            "name": "3Blue1Brown",
            "id": "UCYO_jab_esuFRV4b0cTApqQ"
        },
        {
            "name": "Kurzgesagt",
            "id": "UCzIL6qFP00w10hgxZwplZww"
        },
        {
            "name": "Veritasium",
            "id": "UCHnyfMoQyNFhjVwF1nHV28w"
        }
    ],
    "entertainment": []
}

=== gh-focus/focus_manager.py (Business Logic Module) ===
import json
import os
from datetime import datetime

# Where we store data
CONFIG_FILE = "config.json"
HISTORY_FILE = "watch_history.json"

# Default structure
DEFAULT_CONFIG = {
    "coding": [],
    "business": [],
    "entertainment": []
}

def load_config():
    """Load configuration from JSON file, create if doesn't exist."""
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_CONFIG, f, indent=4)
        return DEFAULT_CONFIG
    
    with open(CONFIG_FILE, "r") as f:
        return json.load(f)

def save_config(data):
    """Save configuration to JSON file."""
    with open(CONFIG_FILE, "w") as f:
        json.dump(data, f, indent=4)

def get_gist_id():
    """Return the stored gist id, if any."""
    data = load_config()
    return data.get("gist_id")

def save_gist_id(gist_id):
    """Persist the gist id into config.json."""
    data = load_config()
    data["gist_id"] = gist_id
    save_config(data)

def add_channel(category, name, channel_id):
    """Add a channel to a specific category."""
    data = load_config()
    if category not in data:
        data[category] = []
    
    # Avoid duplicates
    for ch in data[category]:
        if ch['id'] == channel_id:
            return False
            
    data[category].append({"name": name, "id": channel_id})
    save_config(data)
    return True

def remove_channel(category, channel_id):
    """Remove a channel from a specific category."""
    data = load_config()
    if category not in data:
        return False
    
    data[category] = [ch for ch in data[category] if ch['id'] != channel_id]
    save_config(data)
    return True

def remove_category(category):
    """Remove an entire category."""
    data = load_config()
    if category in data:
        del data[category]
        save_config(data)
        return True
    return False

def get_channels(category):
    """Get all channels in a specific category."""
    data = load_config()
    return data.get(category, [])

def list_all_channels():
    """List all channels across all categories."""
    data = load_config()
    return data

def log_watch(video_title, channel_name, video_id, category):
    """Log a watched video to history."""
    history = []
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            try:
                history = json.load(f)
            except json.JSONDecodeError:
                history = []
    
    history.append({
        "title": video_title,
        "channel": channel_name,
        "video_id": video_id,
        "category": category,
        "timestamp": datetime.now().isoformat()
    })
    
    with open(HISTORY_FILE, "w") as f:
        json.dump(history, f, indent=4)

def get_watch_history():
    """Get all watched videos."""
    if not os.path.exists(HISTORY_FILE):
        return []
    
    with open(HISTORY_FILE, "r") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return []

def get_watch_stats():
    """Get learning statistics."""
    history = get_watch_history()
    if not history:
        return {"total_videos": 0, "total_time": "0h 0m", "categories": {}}
    
    categories = {}
    for video in history:
        cat = video.get("category", "Unknown")
        categories[cat] = categories.get(cat, 0) + 1
    
    # Assume average video is 10 minutes for demo purposes
    total_minutes = len(history) * 10
    hours = total_minutes // 60
    minutes = total_minutes % 60
    
    return {
        "total_videos": len(history),
        "total_time": f"{hours}h {minutes}m",
        "categories": categories,
        "recent": history[-5:] if len(history) > 5 else history
    }

=== gh-focus/fetcher.py (Data Fetching Module with RSS + yt-dlp Fallback) ===
import feedparser
import concurrent.futures
import json
import subprocess
from rich.console import Console

console = Console()

def resolve_channel_id(user_input):
    """
    Resolve a YouTube handle or URL to a channel ID using yt-dlp.
    """
    print(f"[cyan]üîç Resolving ID for '{user_input}'...[/cyan]")

    if not user_input.startswith("http"):
        if not user_input.startswith("@"):
            user_input = f"@{user_input}"
        url = f"https://www.youtube.com/{user_input}"
    else:
        url = user_input

    cmd = [
        "yt-dlp",
        "--playlist-end", "1",
        "--dump-json",
        "--flat-playlist",
        url
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        if result.returncode != 0:
            console.print(f"[yellow]‚ö†Ô∏è  Resolution failed (maybe private channel?)[/yellow]")
            return None

        for line in result.stdout.splitlines():
            try:
                data = json.loads(line)
                if "channel_id" in data:
                    return data["channel_id"]
            except json.JSONDecodeError:
                continue
    except subprocess.TimeoutExpired:
        console.print(f"[red]‚ùå Timeout: couldn't reach YouTube[/red]")
        return None
    except Exception as e:
        console.print(f"[red]Error resolving ID: {e}[/red]")
        return None

    return None

def fetch_videos_yt_dlp(channel):
    """Fallback: Fetch videos using yt-dlp when RSS is disabled."""
    results = []
    try:
        # Try channel URL (safer than /videos which may be blocked)
        url = f"https://www.youtube.com/@{channel['name'].replace(' ', '')}/videos"
        
        cmd = [
            "yt-dlp",
            "--flat-playlist",
            "--playlist-end", "5",
            "--dump-json",
            "--no-warnings",
            "--skip-download",
            url
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        
        if result.returncode == 0 and result.stdout.strip():
            line_count = 0
            for line in result.stdout.splitlines():
                try:
                    data = json.loads(line)
                    if data.get("id"):
                        results.append({
                            "title": data.get("title", "Unknown"),
                            "link": f"https://www.youtube.com/watch?v={data['id']}",
                            "channel": channel['name'],
                            "published": data.get("upload_date", "N/A"),
                            "video_id": data['id']
                        })
                        line_count += 1
                except json.JSONDecodeError:
                    continue
            
            if line_count > 0:
                console.print(f"[green]‚úì Fetched {line_count} videos from {channel['name']} (yt-dlp)[/green]")
                return results
        
        if result.stderr:
            console.print(f"[yellow]‚ö†Ô∏è  {channel['name']}: {result.stderr[:100]}[/yellow]")
    except subprocess.TimeoutExpired:
        console.print(f"[yellow]‚è±Ô∏è  Timeout fetching {channel['name']}[/yellow]")
    except Exception as e:
        console.print(f"[yellow]‚ùå yt-dlp error for {channel['name']}: {str(e)[:80]}[/yellow]")
    
    return results


def fetch_single_channel(channel):
    """Fetch videos for a single channel."""
    rss_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel['id']}"
    results = []
    try:
        feed = feedparser.parse(rss_url)
        if not feed.entries:
            console.print(f"[cyan]‚ÑπÔ∏è  {channel['name']}: Trying alternate fetch method...[/cyan]")
            return fetch_videos_yt_dlp(channel)
        for entry in feed.entries[:3]:
            results.append({
                "title": entry.title,
                "link": entry.link,
                "channel": channel['name'],
                "published": entry.published,
                "video_id": entry.yt_videoid
            })
    except Exception as e:
        console.print(f"[cyan]‚ÑπÔ∏è  {channel['name']}: Trying alternate fetch method...[/cyan]")
        return fetch_videos_yt_dlp(channel)
    return results

def get_videos(channel_list):
    """
    Fetch latest videos from YouTube channels using RSS feeds.
    No API key required!
    """
    videos = []

    with console.status("[bold green]Fetching content (Parallel Mode)...[/bold green]"):
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(fetch_single_channel, ch) for ch in channel_list]
            for future in concurrent.futures.as_completed(futures):
                videos.extend(future.result())

    return videos

def extract_channel_id(channel_url):
    """Back-compat wrapper for old code paths."""
    return resolve_channel_id(channel_url)

=== gh-focus/gh-focus (MAIN CLI SCRIPT - COMPLETE LATEST VERSION - 894 LINES) ===
See the gh-focus file in the repository for the complete main CLI script with all features:
- Custom category creation with normalization
- Input validation (is_valid_channel_id, is_valid_handle_or_url, normalize_category_name)
- Channel and category removal with confirmation
- Rich terminal UI with colored tables, panels, and organized menus
- Professional dashboard with statistics and learning history
- Multiple player support (MPV, VLC, Browser fallback)
- GitHub Gist integration for learning logs
- Watch history tracking
- RSS + yt-dlp fallback for video fetching
- Error handling and user feedback

=== LATEST FEATURES SUMMARY ===
‚úÖ Custom category creation with text normalization
   - normalize_category_name(): Converts "my data science" ‚Üí "my_data_science"

‚úÖ Robust input validation
   - is_valid_channel_id(): Validates UC[+22 chars] format
   - is_valid_handle_or_url(): Accepts @handles, URLs, or IDs
   - Prevents invalid channel entries and guides users

‚úÖ Channel and category management
   - remove_channel(): Delete individual channels with confirmation
   - remove_category(): Delete entire categories with safety prompt
   - Add, list, and organize channels by category

‚úÖ Professional CLI interface (Rich library)
   - Colored tables for channel display
   - Info panels for video details
   - Organized menu sections (Categories ‚Üí Tools ‚Üí Exit)
   - Dashboard with stats, category breakdown, recent history

‚úÖ Intelligent video fetching
   - Primary: RSS feeds (fast, no API key needed)
   - Fallback: yt-dlp scraping (for RSS-disabled channels like Raj Shamani)
   - Parallel fetching (10 concurrent workers)
   - Error handling with user feedback

‚úÖ Multiple video players
   - Local MPV.exe (portable, ad-free)
   - System MPV (lightweight)
   - VLC Media Player (backup)
   - Browser (final fallback)

‚úÖ Learning analytics
   - Watch history with timestamps
   - Statistics dashboard (videos, time, top category)
   - Category breakdown
   - Recent learning activity tracking

‚úÖ GitHub integration (optional)
   - Sync watching to GitHub Gist
   - Create/update public learning logs
   - Mark videos as complete/incomplete
   - View full log in browser

‚úÖ Production quality
   - Syntax optimized (no nested brackets in f-strings)
   - Error handling for all edge cases
   - Auto-install dependencies on first run
   - Configuration persistence (JSON files)
   - Command-line arguments (--stats, --help)

=== DEPLOYMENT ===
Both repositories pushed successfully to GitHub:
- Main repo: https://github.com/Pakeeza1508/github-cli-challenge
- Submodule: https://github.com/Pakeeza1508/gh-focus

Ready for hackathon submission!
