=== gh-focus.cmd ===
@echo off
REM GitHub CLI extension entry point for Windows
REM This script runs the Python CLI

setlocal

REM Get the directory where the extension is installed
set "EXTENSION_DIR=%~dp0"

REM Check if Python is installed
where python >nul 2>nul
if %errorlevel% neq 0 (
    echo Error: Python is required but not found.
    echo Please install Python 3.7+ from https://www.python.org/downloads/
    exit /b 1
)

REM Check if virtual environment exists, create if not
if not exist "%EXTENSION_DIR%gh-focus\venv" (
    echo Setting up gh-focus for first time...
    python -m venv "%EXTENSION_DIR%gh-focus\venv"
    call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"
    pip install -q -r "%EXTENSION_DIR%gh-focus\requirements.txt"
    echo Setup complete!
)

REM Activate virtual environment
call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"

REM Run the actual Python script
cd /d "%EXTENSION_DIR%gh-focus"
python gh-focus %*

=== gh-focus/requirements.txt ===
feedparser>=6.0.10
questionary>=2.0.1
rich>=13.7.0
yt-dlp>=2023.0.0

=== gh-focus/config.json.sample ===
{
    "coding": [
        {
            "name": "Fireship",
            "id": "UCsBjURrPoezykLs9EqgamOA"
        },
        {
            "name": "Traversy Media",
            "id": "UC29ju8bIPH5as8OGnQzwJyA"
        },
        {
            "name": "Web Dev Simplified",
            "id": "UCFbNIlppjreqWp0LoG4qLDg"
        },
        {
            "name": "The Net Ninja",
            "id": "UCW5YeuERMlsx2D7KtykVbVA"
        }
    ],
    "business": [
        {
            "name": "Y Combinator",
            "id": "UCcefcZRL2oaA_uBNeo5UOWg"
        },
        {
            "name": "Ali Abdaal",
            "id": "UCoOae5nYzcosPVc4DescXIQ"
        },
        {
            "name": "MeetKevin",
            "id": "UCdWjx1aWCM6iB2lt-dEKD8w"
        }
    ],
    "learning": [
        {
            "name": "3Blue1Brown",
            "id": "UCYO_jab_esuFRV4b0cTApqQ"
        },
        {
            "name": "Kurzgesagt",
            "id": "UCzIL6qFP00w10hgxZwplZww"
        },
        {
            "name": "Veritasium",
            "id": "UCHnyfMoQyNFhjVwF1nHV28w"
        }
    ],
    "entertainment": []
}

=== gh-focus/focus_manager.py (Business Logic Module) ===
import json
import os
from datetime import datetime

# Where we store data
CONFIG_FILE = "config.json"
HISTORY_FILE = "watch_history.json"

# Default structure
DEFAULT_CONFIG = {
    "coding": [],
    "business": [],
    "entertainment": []
}

def load_config():
    """Load configuration from JSON file, create if doesn't exist."""
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_CONFIG, f, indent=4)
        return DEFAULT_CONFIG
    
    with open(CONFIG_FILE, "r") as f:
        return json.load(f)

def save_config(data):
    """Save configuration to JSON file."""
    with open(CONFIG_FILE, "w") as f:
        json.dump(data, f, indent=4)

def get_gist_id():
    """Return the stored gist id, if any."""
    data = load_config()
    return data.get("gist_id")

def save_gist_id(gist_id):
    """Persist the gist id into config.json."""
    data = load_config()
    data["gist_id"] = gist_id
    save_config(data)

def add_channel(category, name, channel_id):
    """Add a channel to a specific category."""
    data = load_config()
    if category not in data:
        data[category] = []
    
    # Avoid duplicates
    for ch in data[category]:
        if ch['id'] == channel_id:
            return False
            
    data[category].append({"name": name, "id": channel_id})
    save_config(data)
    return True

def remove_channel(category, channel_id):
    """Remove a channel from a specific category."""
    data = load_config()
    if category not in data:
        return False
    
    data[category] = [ch for ch in data[category] if ch['id'] != channel_id]
    save_config(data)
    return True

def remove_category(category):
    """Remove an entire category."""
    data = load_config()
    if category in data:
        del data[category]
        save_config(data)
        return True
    return False

def get_channels(category):
    """Get all channels in a specific category."""
    data = load_config()
    return data.get(category, [])

def list_all_channels():
    """List all channels across all categories."""
    data = load_config()
    return data

def log_watch(video_title, channel_name, video_id, category):
    """Log a watched video to history."""
    history = []
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            try:
                history = json.load(f)
            except json.JSONDecodeError:
                history = []
    
    history.append({
        "title": video_title,
        "channel": channel_name,
        "video_id": video_id,
        "category": category,
        "timestamp": datetime.now().isoformat()
    })
    
    with open(HISTORY_FILE, "w") as f:
        json.dump(history, f, indent=4)

def get_watch_history():
    """Get all watched videos."""
    if not os.path.exists(HISTORY_FILE):
        return []
    
    with open(HISTORY_FILE, "r") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return []

def get_watch_stats():
    """Get learning statistics."""
    history = get_watch_history()
    if not history:
        return {"total_videos": 0, "total_time": "0h 0m", "categories": {}}
    
    categories = {}
    for video in history:
        cat = video.get("category", "Unknown")
        categories[cat] = categories.get(cat, 0) + 1
    
    # Assume average video is 10 minutes for demo purposes
    total_minutes = len(history) * 10
    hours = total_minutes // 60
    minutes = total_minutes % 60
    
    return {
        "total_videos": len(history),
        "total_time": f"{hours}h {minutes}m",
        "categories": categories,
        "recent": history[-5:] if len(history) > 5 else history
    }

=== gh-focus/fetcher.py (Data Fetching Module with RSS + yt-dlp Fallback) ===
import feedparser
import concurrent.futures
import json
import subprocess
from rich.console import Console

console = Console()

def resolve_channel_id(user_input):
    """
    Resolve a YouTube handle or URL to a channel ID using yt-dlp.
    """
    print(f"[cyan]üîç Resolving ID for '{user_input}'...[/cyan]")

    if not user_input.startswith("http"):
        if not user_input.startswith("@"):
            user_input = f"@{user_input}"
        url = f"https://www.youtube.com/{user_input}"
    else:
        url = user_input

    cmd = [
        "yt-dlp",
        "--playlist-end", "1",
        "--dump-json",
        "--flat-playlist",
        url
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        if result.returncode != 0:
            console.print(f"[yellow]‚ö†Ô∏è  Resolution failed (maybe private channel?)[/yellow]")
            return None

        for line in result.stdout.splitlines():
            try:
                data = json.loads(line)
                if "channel_id" in data:
                    return data["channel_id"]
            except json.JSONDecodeError:
                continue
    except subprocess.TimeoutExpired:
        console.print(f"[red]‚ùå Timeout: couldn't reach YouTube[/red]")
        return None
    except Exception as e:
        console.print(f"[red]Error resolving ID: {e}[/red]")
        return None

    return None

def fetch_videos_yt_dlp(channel):
    """Fallback: Fetch videos using yt-dlp when RSS is disabled."""
    results = []
    try:
        # Try channel URL (safer than /videos which may be blocked)
        url = f"https://www.youtube.com/@{channel['name'].replace(' ', '')}/videos"
        
        cmd = [
            "yt-dlp",
            "--flat-playlist",
            "--playlist-end", "5",
            "--dump-json",
            "--no-warnings",
            "--skip-download",
            url
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
        
        if result.returncode == 0 and result.stdout.strip():
            line_count = 0
            for line in result.stdout.splitlines():
                try:
                    data = json.loads(line)
                    if data.get("id"):
                        results.append({
                            "title": data.get("title", "Unknown"),
                            "link": f"https://www.youtube.com/watch?v={data['id']}",
                            "channel": channel['name'],
                            "published": data.get("upload_date", "N/A"),
                            "video_id": data['id']
                        })
                        line_count += 1
                except json.JSONDecodeError:
                    continue
            
            if line_count > 0:
                console.print(f"[green]‚úì Fetched {line_count} videos from {channel['name']} (yt-dlp)[/green]")
                return results
        
        if result.stderr:
            console.print(f"[yellow]‚ö†Ô∏è  {channel['name']}: {result.stderr[:100]}[/yellow]")
    except subprocess.TimeoutExpired:
        console.print(f"[yellow]‚è±Ô∏è  Timeout fetching {channel['name']}[/yellow]")
    except Exception as e:
        console.print(f"[yellow]‚ùå yt-dlp error for {channel['name']}: {str(e)[:80]}[/yellow]")
    
    return results


def fetch_single_channel(channel):
    """Fetch videos for a single channel."""
    rss_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel['id']}"
    results = []
    try:
        feed = feedparser.parse(rss_url)
        if not feed.entries:
            console.print(f"[cyan]‚ÑπÔ∏è  {channel['name']}: Trying alternate fetch method...[/cyan]")
            return fetch_videos_yt_dlp(channel)
        for entry in feed.entries[:3]:
            results.append({
                "title": entry.title,
                "link": entry.link,
                "channel": channel['name'],
                "published": entry.published,
                "video_id": entry.yt_videoid
            })
    except Exception as e:
        console.print(f"[cyan]‚ÑπÔ∏è  {channel['name']}: Trying alternate fetch method...[/cyan]")
        return fetch_videos_yt_dlp(channel)
    return results

def get_videos(channel_list):
    """
    Fetch latest videos from YouTube channels using RSS feeds.
    No API key required!
    """
    videos = []

    with console.status("[bold green]Fetching content (Parallel Mode)...[/bold green]"):
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(fetch_single_channel, ch) for ch in channel_list]
            for future in concurrent.futures.as_completed(futures):
                videos.extend(future.result())

    return videos

def extract_channel_id(channel_url):
    """Back-compat wrapper for old code paths."""
    return resolve_channel_id(channel_url)

=== gh-focus/gh-focus (MAIN CLI SCRIPT - COMPLETE LATEST VERSION - 894 LINES) ===
See the gh-focus file in the repository for the complete main CLI script with all features:
- Custom category creation with normalization
- Input validation (is_valid_channel_id, is_valid_handle_or_url, normalize_category_name)
- Channel and category removal with confirmation
- Rich terminal UI with colored tables, panels, and organized menus
- Professional dashboard with statistics and learning history
- Multiple player support (MPV, VLC, Browser fallback)
- GitHub Gist integration for learning logs
- Watch history tracking
- RSS + yt-dlp fallback for video fetching
- Error handling and user feedback

=== LATEST FEATURES SUMMARY ===
‚úÖ Custom category creation with text normalization
   - normalize_category_name(): Converts "my data science" ‚Üí "my_data_science"

‚úÖ Robust input validation
   - is_valid_channel_id(): Validates UC[+22 chars] format
   - is_valid_handle_or_url(): Accepts @handles, URLs, or IDs
   - Prevents invalid channel entries and guides users

‚úÖ Channel and category management
   - remove_channel(): Delete individual channels with confirmation
   - remove_category(): Delete entire categories with safety prompt
   - Add, list, and organize channels by category

‚úÖ Professional CLI interface (Rich library)
   - Colored tables for channel display
   - Info panels for video details
   - Organized menu sections (Categories ‚Üí Tools ‚Üí Exit)
   - Dashboard with stats, category breakdown, recent history

‚úÖ Intelligent video fetching
   - Primary: RSS feeds (fast, no API key needed)
   - Fallback: yt-dlp scraping (for RSS-disabled channels like Raj Shamani)
   - Parallel fetching (10 concurrent workers)
   - Error handling with user feedback

‚úÖ Multiple video players
   - Local MPV.exe (portable, ad-free)
   - System MPV (lightweight)
   - VLC Media Player (backup)
   - Browser (final fallback)

‚úÖ Learning analytics
   - Watch history with timestamps
   - Statistics dashboard (videos, time, top category)
   - Category breakdown
   - Recent learning activity tracking

‚úÖ GitHub integration (optional)
   - Sync watching to GitHub Gist
   - Create/update public learning logs
   - Mark videos as complete/incomplete
   - View full log in browser

‚úÖ Production quality
   - Syntax optimized (no nested brackets in f-strings)
   - Error handling for all edge cases
   - Auto-install dependencies on first run
   - Configuration persistence (JSON files)
   - Command-line arguments (--stats, --help)

=== DEPLOYMENT ===
Both repositories pushed successfully to GitHub:
- Main repo: https://github.com/Pakeeza1508/github-cli-challenge
- Submodule: https://github.com/Pakeeza1508/gh-focus

Ready for hackathon submission!
