=== gh-focus.cmd ===
@echo off
REM GitHub CLI extension entry point for Windows
REM This script runs the Python CLI

setlocal

REM Get the directory where the extension is installed
set "EXTENSION_DIR=%~dp0"

REM Check if Python is installed
where python >nul 2>nul
if %errorlevel% neq 0 (
    echo Error: Python is required but not found.
    echo Please install Python 3.7+ from https://www.python.org/downloads/
    exit /b 1
)

REM Check if virtual environment exists, create if not
if not exist "%EXTENSION_DIR%gh-focus\venv" (
    echo Setting up gh-focus for first time...
    python -m venv "%EXTENSION_DIR%gh-focus\venv"
    call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"
    pip install -q -r "%EXTENSION_DIR%gh-focus\requirements.txt"
    echo Setup complete!
)

REM Activate virtual environment
call "%EXTENSION_DIR%gh-focus\venv\Scripts\activate.bat"

REM Run the actual Python script
cd /d "%EXTENSION_DIR%gh-focus"
python gh-focus %*

=== gh-focus/gh-focus ===
#!/usr/bin/env python3
"""
gh-focus: A distraction-free YouTube CLI for focused learning
GitHub CLI Extension for the 2026 Challenge
"""

import sys
import webbrowser
import subprocess
import shutil
import os
import questionary
from rich import print
from rich.panel import Panel
from focus_manager import load_config, add_channel, log_watch, get_watch_stats, get_gist_id, save_gist_id
from fetcher import get_videos

def check_gh_auth():
    """Checks if gh CLI is installed and logged in."""
    try:
        subprocess.run(
            ["gh", "auth", "status"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True
        )
        return True
    except FileNotFoundError:
        print("[bold red]âŒ GitHub CLI (gh) is not installed![/bold red]")
        print("Install it here: https://cli.github.com/")
        return False
    except subprocess.CalledProcessError:
        print("[bold red]âŒ You are not logged into GitHub![/bold red]")
        print("Please run: [yellow]gh auth login[/yellow]")
        return False

def save_to_learning_log(video_title, video_url):
    """Append the video to a shared learning log Gist."""
    if not check_gh_auth():
        return

    print("[bold yellow]ðŸ± Syncing with GitHub...[/bold yellow]")

    gist_id = get_gist_id()
    filename = "focus_learning_log.md"
    new_entry = f"- [ ] **{video_title}** - [Watch]({video_url})\n"

    script_dir = os.path.dirname(os.path.abspath(__file__))
    temp_path = os.path.join(script_dir, filename)

    if not gist_id:
        print("[cyan]Creating new Learning Log Gist...[/cyan]")
        description = "My Developer Learning Path (Created by gh-focus)"

        with open(temp_path, "w", encoding="utf-8") as f:
            f.write(f"# My Intentional Learning Log ðŸ§ \n\n{new_entry}")

        try:
            subprocess.run(
                ["gh", "gist", "create", temp_path, "--desc", description, "--public"],
                check=True
            )

            res = subprocess.run(
                ["gh", "gist", "list", "--limit", "1"],
                capture_output=True,
                text=True,
                check=True
            )
            new_id = res.stdout.split()[0]
            save_gist_id(new_id)
            print(f"[bold green]âœ… Created & Saved to Gist ID: {new_id}[/bold green]")
        except subprocess.CalledProcessError as exc:
            print("[bold red]âŒ Failed to create the Learning Log Gist.[/bold red]")
            if exc.stderr:
                print(exc.stderr)
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
    else:
        print(f"[cyan]Updating Gist {gist_id}...[/cyan]")
        try:
            res = subprocess.run(
                ["gh", "gist", "view", gist_id, "--filename", filename],
                capture_output=True,
                text=True,
                check=True
            )
            current_content = res.stdout
            updated_content = current_content + new_entry

            with open(temp_path, "w", encoding="utf-8") as f:
                f.write(updated_content)

            subprocess.run(["gh", "gist", "edit", gist_id, temp_path], check=True)
            print(f"[bold green]âœ… Added '{video_title}' to your Learning Log![/bold green]")
        except subprocess.CalledProcessError as exc:
            print("[bold red]âŒ Failed to update the Learning Log Gist.[/bold red]")
            if exc.stderr:
                print(exc.stderr)
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)

def open_safe_mode(video_id):
    """
    Opens video using the local mpv.exe if found, otherwise tries system players.
    """
    url = f"https://www.youtube.com/watch?v={video_id}"

    # 1. Check for mpv.exe in the SAME folder as this script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    local_mpv = os.path.join(script_dir, "mpv.exe")

    if os.path.exists(local_mpv):
        print(f"[bold green]ðŸš€ Launching Portable MPV...[/bold green]")
        # We need to pass the full path to yt-dlp if it's not in PATH,
        # but since you pip installed it, mpv should find it automatically.
        subprocess.run([local_mpv, url])
        return

    # 2. Check for System MPV (Global install)
    if shutil.which("mpv"):
        print(f"[bold green]ðŸš€ Launching System MPV...[/bold green]")
        subprocess.run(["mpv", url])
        return

    # 3. Check for VLC (Backup)
    vlc_path = shutil.which("vlc")
    if not vlc_path:
        # Check standard Windows paths
        paths = [
            r"C:\Program Files\VideoLAN\VLC\vlc.exe",
            r"C:\Program Files (x86)\VideoLAN\VLC\vlc.exe"
        ]
        for p in paths:
            if os.path.exists(p):
                vlc_path = p
                break

    if vlc_path:
        print(f"[bold orange3]ðŸŽ¬ Launching VLC...[/bold orange3]")
        subprocess.run([vlc_path, url, "--play-and-exit"])
        return

    # 4. Give up and use Browser
    print("[bold red]âŒ No Player Found![/bold red]")
    print(f"Please copy 'mpv.exe' into this folder: {script_dir}")
    print("[yellow]Falling back to Browser...[/yellow]")
    webbrowser.open(url)

def show_banner():
    """Display welcome banner."""
    print(Panel.fit("[bold white]ðŸŽ¯ YouTube Focus Mode[/bold white]\n[cyan]Curated. Intentional. Focused.[/cyan]", border_style="cyan"))

def show_stats():
    """Display learning statistics."""
    stats = get_watch_stats()

    print(Panel(
        f"[bold cyan]ðŸ“Š Your Learning Stats[/bold cyan]\n"
        f"[green]Videos Watched:[/green] {stats['total_videos']}\n"
        f"[green]Total Time:[/green] {stats['total_time']}\n"
        f"[green]Categories:[/green] {', '.join([f'{k} ({v})' for k, v in stats['categories'].items()]) if stats['categories'] else 'None'}",
        border_style="cyan"
    ))

    if stats['recent']:
        print("\n[bold cyan]ðŸ“º Recent Videos:[/bold cyan]")
        for video in reversed(stats['recent']):
            date = video.get('timestamp', '').split('T')[0]
            print(f"  âœ“ {video['title'][:50]}... ({date})")

def main():
    # Handle command-line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--stats":
            show_stats()
            return
        elif sys.argv[1] == "--help":
            print("[cyan]Usage:[/cyan]")
            print("  python gh-focus          Start interactive mode")
            print("  python gh-focus --stats  Show learning statistics")
            print("  python gh-focus --help   Show this help message")
            return

    show_banner()

    if not check_gh_auth():
        sys.exit(1)

    # MAIN LOOP: Keeps the app running
    while True:
        config = load_config()

        # 1. Ask for Mood (Category)
        categories = [key for key, value in config.items() if isinstance(value, list)]
        main_options = categories + ["ðŸ“Š View Stats", "+ Add New Channel", "Exit"]

        choice = questionary.select(
            "What is your focus right now?",
            choices=main_options,
            style=questionary.Style([('answer', 'fg:cyan bold')])
        ).ask()

        # Handle Main Menu Exits
        if choice == "Exit":
            print("[bold red]Stay focused! Goodbye. ðŸ‘‹[/bold red]")
            sys.exit()

        if choice == "ðŸ“Š View Stats":
            show_stats()
            questionary.confirm("Press Enter to continue...").ask()
            continue

        if choice == "+ Add New Channel":
            cat = questionary.select(
                "Which category?",
                choices=categories
            ).ask()

            name = questionary.text("Channel Name (e.g., Fireship):").ask()
            c_id = questionary.text("Channel ID (starts with UC...):").ask()

            if add_channel(cat, name, c_id):
                print(f"[green]âœ“ Added {name} to {cat}![/green]")
            else:
                print(f"[yellow]Channel already exists in {cat}[/yellow]")
            continue  # Go back to start of loop

        # 2. Fetch Videos for that category
        channels = config[choice]
        if not channels:
            print("[red]No channels in this list yet![/red]")
            print("[yellow]Tip: Select '+ Add New Channel' to get started[/yellow]")
            continue

        # INNER LOOP: Stay in this category until user goes back
        while True:
            videos = get_videos(channels)

            if not videos:
                print("[yellow]No recent videos found.[/yellow]")
                break

            # 3. Create the Selection List
            video_choices = []
            video_map = {}
            video_info = {}

            for v in videos:
                # ðŸš« BLOCK SHORTS: Skip short-form content
                if "#shorts" in v['title'].lower() or "short" in v['title'].lower():
                    continue

                # Clean up title for display
                display_text = f"[{v['channel']}] {v['title'][:60]}"
                video_choices.append(display_text)
                video_map[display_text] = v['video_id']
                video_info[display_text] = v

            if not video_choices:
                print("[yellow]No full-length videos found (only Shorts).[/yellow]")
                break

            # Add Navigation
            video_choices.append("ðŸ”™ Go Back")
            video_choices.append("âŒ Exit App")

            selected_text = questionary.select(
                f"ðŸ“º {choice.upper()} - Select video:",
                choices=video_choices
            ).ask()

            # Navigation Logic
            if selected_text == "âŒ Exit App":
                print("[bold red]Goodbye! ðŸ‘‹[/bold red]")
                sys.exit()

            if selected_text == "ðŸ”™ Go Back":
                break  # Breaks inner loop, goes back to Main Menu

            # Choose action for the selected video
            video_id = video_map[selected_text]
            video_data = video_info[selected_text]
            action = questionary.select(
                f"Action for: {selected_text.split('|')[-1].strip()}",
                choices=[
                    "ðŸ“º Stream (Watch Now)",
                    "ðŸ’¾ Save to Learning Log",
                    "ðŸ”™ Cancel"
                ]
            ).ask()

            if action == "ðŸ“º Stream (Watch Now)":
                print(f"\n[bold yellow]ðŸŽ¬ {selected_text}[/bold yellow]")
                print("[dim]YouTube will open. Close the tab when done to return here.[/dim]\n")

                log_watch(
                    video_data['title'],
                    video_data['channel'],
                    video_id,
                    choice
                )

                open_safe_mode(video_id)
            elif action == "ðŸ’¾ Save to Learning Log":
                clean_title = selected_text.split("] ")[-1]
                full_url = f"https://www.youtube.com/watch?v={video_id}"
                save_to_learning_log(clean_title, full_url)
                input("Press Enter to continue...")
            # The loop continues, so you come back to the video list!

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[bold red]Force Exit. Stay focused! ðŸ‘‹[/bold red]")
        sys.exit(0)
    except Exception as e:
        print(f"[red]Error: {e}[/red]")
        sys.exit(1)

=== gh-focus/fetcher.py ===
import feedparser
from rich.console import Console

console = Console()

def get_videos(channel_list):
    """
    Fetch latest videos from YouTube channels using RSS feeds.
    No API key required!
    """
    videos = []

    with console.status("[bold green]Fetching latest intentional content..."):
        for channel in channel_list:
            # The Magic URL (No API Key needed)
            rss_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel['id']}"

            try:
                feed = feedparser.parse(rss_url)

                # Get the last 3 videos from this channel
                for entry in feed.entries[:3]:
                    videos.append({
                        "title": entry.title,
                        "link": entry.link,
                        "channel": channel['name'],
                        "published": entry.published,
                        "video_id": entry.yt_videoid  # Feedparser extracts this for us
                    })
            except Exception as e:
                console.print(f"[red]Error fetching from {channel['name']}: {e}[/red]")
                continue

    # Sort by newest first (simplified for now)
    return videos

def extract_channel_id(channel_url):
    """
    Extract channel ID from a YouTube channel URL.
    Supports formats:
    - youtube.com/channel/UC...
    - youtube.com/@username
    """
    # This is a placeholder - in Phase 2 we can add proper extraction
    # For now, users will paste the ID directly
    if "channel/" in channel_url:
        return channel_url.split("channel/")[-1].split("/")[0]
    return None

=== gh-focus/focus_manager.py ===
import json
import os
from datetime import datetime

# Where we store data
CONFIG_FILE = "config.json"
HISTORY_FILE = "watch_history.json"

# Default structure
DEFAULT_CONFIG = {
    "coding": [],
    "business": [],
    "entertainment": []
}

def load_config():
    """Load configuration from JSON file, create if doesn't exist."""
    if not os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_CONFIG, f, indent=4)
        return DEFAULT_CONFIG

    with open(CONFIG_FILE, "r") as f:
        return json.load(f)

def save_config(data):
    """Save configuration to JSON file."""
    with open(CONFIG_FILE, "w") as f:
        json.dump(data, f, indent=4)

def get_gist_id():
    """Return the stored gist id, if any."""
    data = load_config()
    return data.get("gist_id")

def save_gist_id(gist_id):
    """Persist the gist id into config.json."""
    data = load_config()
    data["gist_id"] = gist_id
    save_config(data)

def add_channel(category, name, channel_id):
    """Add a channel to a specific category."""
    data = load_config()
    if category not in data:
        data[category] = []

    # Avoid duplicates
    for ch in data[category]:
        if ch['id'] == channel_id:
            return False

    data[category].append({"name": name, "id": channel_id})
    save_config(data)
    return True

def get_channels(category):
    """Get all channels in a specific category."""
    data = load_config()
    return data.get(category, [])

def list_all_channels():
    """List all channels across all categories."""
    data = load_config()
    return data

def log_watch(video_title, channel_name, video_id, category):
    """Log a watched video to history."""
    history = []
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            try:
                history = json.load(f)
            except json.JSONDecodeError:
                history = []

    history.append({
        "title": video_title,
        "channel": channel_name,
        "video_id": video_id,
        "category": category,
        "timestamp": datetime.now().isoformat()
    })

    with open(HISTORY_FILE, "w") as f:
        json.dump(history, f, indent=4)

def get_watch_history():
    """Get all watched videos."""
    if not os.path.exists(HISTORY_FILE):
        return []

    with open(HISTORY_FILE, "r") as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return []

def get_watch_stats():
    """Get learning statistics."""
    history = get_watch_history()
    if not history:
        return {"total_videos": 0, "total_time": "0h 0m", "categories": {}}

    categories = {}
    for video in history:
        cat = video.get("category", "Unknown")
        categories[cat] = categories.get(cat, 0) + 1

    # Assume average video is 10 minutes for demo purposes
    total_minutes = len(history) * 10
    hours = total_minutes // 60
    minutes = total_minutes % 60

    return {
        "total_videos": len(history),
        "total_time": f"{hours}h {minutes}m",
        "categories": categories,
        "recent": history[-5:] if len(history) > 5 else history
    }
